{"mappings":"AAgUAA,OAAOC,YAAc,CAAEC,KAAM","sources":["index.js"],"sourcesContent":["// import get from 'lodash.get'\r\n// import set from 'lodash.set'\r\n// import axios from 'axios'\r\n\r\n// const webflawless = { data: {} }\r\n// const listeners = { saved: {} }\r\n\r\n// const helpers = {\r\n//   getNodesFromSelector: ({ selector, contextNode }) => {\r\n//     if (typeof selector === 'string' || selector.type === 'css') {\r\n//       return Array.from(document.querySelectorAll(selector))\r\n//     } else if (selector.type === 'id') {\r\n//       return [document.getElementById(selector.value)]\r\n//     } else if (selector.type === 'class') {\r\n//       return Array.from(document.getElementsByClassName(selector.value.toLowerCase().replace(/\\s/g, '-')))\r\n//     } else if (selector.type === 'tag') {\r\n//       const nodes = []\r\n\r\n//       const snapshotTags = document.evaluate(`descendant-or-self::*[contains(text(), \"[${'webflawless'}:\")]`, contextNode, null, window.XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null)\r\n//       const snapshotAttributes = document.evaluate(`descendant-or-self::*/@*[contains(., \"[${'webflawless'}:\")]`, contextNode, null, window.XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null)\r\n\r\n//       for (const index in [...new Array(snapshotTags.snapshotLength)]) {\r\n//         nodes.push(snapshotTags.snapshotItem(index))\r\n//       }\r\n\r\n//       for (const index in [...new Array(snapshotAttributes.snapshotLength)]) {\r\n//         nodes.push(snapshotAttributes.snapshotItem(index))\r\n//       }\r\n\r\n//       return nodes\r\n//     }\r\n\r\n//     return null\r\n//   },\r\n//   replaceValueFromNode: ({ node, inputs }) => {\r\n//     if (node.innerText) {\r\n//       (node.innerText.match(/\\[webflawless:[^\\]]+\\]/g) || []).map(tag => {\r\n//         const input = tag.replace('[webflawless:', '').replace(']', '')\r\n\r\n//         if (input && typeof inputs[input] !== 'undefined') {\r\n//           node.innerText = node.innerText.replace(new RegExp(`\\\\[webflawless:${input}\\\\]`, 'g'), inputs[input])\r\n//         }\r\n\r\n//         return null\r\n//       })\r\n//     }\r\n\r\n//     if (node.value) {\r\n//       (node.value.match(/\\[webflawless:[^\\]]+\\]/g) || []).map(tag => {\r\n//         const input = tag.replace('[webflawless:', '').replace(']', '')\r\n\r\n//         if (input && typeof inputs[input] !== 'undefined') {\r\n//           node.value = node.value.replace(new RegExp(`\\\\[webflawless:${input}\\\\]`, 'g'), inputs[input])\r\n\r\n//           if (node.name === 'webflawless-checked' && inputs[input]) {\r\n//             node.ownerElement.checked = true\r\n//           } else if (node.name === 'webflawless-src' && inputs[input]) {\r\n//             node.ownerElement.src = inputs[input]\r\n//             node.ownerElement.srcset = inputs[input]\r\n//           } else if (node.name === 'webflawless-href' && inputs[input]) {\r\n//             node.ownerElement.href = inputs[input]\r\n//           } else if (node.name === 'webflawless-value' && inputs[input]) {\r\n//             node.ownerElement.value = inputs[input]\r\n//           }\r\n//         }\r\n\r\n//         return null\r\n//       })\r\n//     }\r\n//   },\r\n//   getInputs: ({ inputs, map }) => {\r\n//     let data\r\n\r\n//     if (typeof inputs === 'string' && (inputs.startsWith('data.') || inputs.startsWith('data['))) {\r\n//       data = get(webflawless, inputs)\r\n//       // } else if (typeof inputs === 'number') {\r\n//       //   data = [...Array(inputs)].map((_, index) => ({ index }))\r\n//     } else {\r\n//       data = JSON.parse(JSON.stringify(inputs))\r\n//     }\r\n\r\n//     if (!Array.isArray(data) && typeof data === 'object') {\r\n//       for (const key in data) {\r\n//         if (typeof data[key] === 'string' && (data[key].startsWith('data.') || data[key].startsWith('data['))) {\r\n//           data[key] = get(webflawless, data[key])\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     if (map) {\r\n//       if (Array.isArray(data)) {\r\n//         data = data.map(item => {\r\n//           const newItem = {}\r\n\r\n//           for (const key in map) {\r\n//             newItem[key] = get(item, map[key])\r\n//           }\r\n\r\n//           return newItem\r\n//         })\r\n//       } else if (typeof data === 'object') {\r\n//         for (const key in map) {\r\n//           data[key] = get(data, map[key])\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return data\r\n//   },\r\n//   insertNodeAfter: ({ newNode, referenceNode }) => {\r\n//     referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling)\r\n//   },\r\n//   request: ({ url, method, data, headers, urlParams, saveAs, actionOnLoad }) => {\r\n//     axios.request({ url, method: method || 'get', data, headers, params: urlParams })\r\n//       .then(({ data }) => {\r\n//         if (saveAs) {\r\n//           webflawless.data.saved[saveAs] = data\r\n\r\n//           if (listeners.saved[saveAs]) {\r\n//             listeners.saved[saveAs].map(action => webflawless.action(action))\r\n//           }\r\n\r\n//           if (saveAs === 'local') {\r\n//             window.localStorage.setItem('webflawless', JSON.stringify(webflawless.data.saved.local))\r\n//           } else if (saveAs === 'session') {\r\n//             window.localStorage.setItem('webflawless', JSON.stringify(webflawless.data.saved.session))\r\n//           }\r\n//         }\r\n\r\n//         if (actionOnLoad) {\r\n//           webflawless.action(actionOnLoad)\r\n//         }\r\n//       })\r\n//   }\r\n// }\r\n\r\n// webflawless.condition = (left, condition, right) => {\r\n//   if (condition === 'equals') {\r\n//     return helpers.getInputs({ inputs: left }) === helpers.getInputs({ inputs: right })\r\n//   } else if (condition === 'does not equal') {\r\n//     return helpers.getInputs({ inputs: left }) !== helpers.getInputs({ inputs: right })\r\n//   } else if (condition === 'exists') {\r\n//     return helpers.getInputs({ inputs: left })\r\n//   } else if (condition === 'does not exist') {\r\n//     return !helpers.getInputs({ inputs: left })\r\n//   } else if (condition === 'less than') {\r\n//     return helpers.getInputs({ inputs: left }) < helpers.getInputs({ inputs: right })\r\n//   } else if (condition === 'more than') {\r\n//     return helpers.getInputs({ inputs: left }) > helpers.getInputs({ inputs: right })\r\n//   } else if (condition === 'contains') {\r\n//     return helpers.getInputs({ inputs: left }).includes(helpers.getInputs({ inputs: right }))\r\n//   } else if (condition === 'does not contain') {\r\n//     return !helpers.getInputs({ inputs: left }).includes(helpers.getInputs({ inputs: right }))\r\n//   } else if (condition === 'and') {\r\n//     return helpers.getInputs({ inputs: left }) && helpers.getInputs({ inputs: right })\r\n//   } else if (condition === 'or') {\r\n//     return helpers.getInputs({ inputs: left }) || helpers.getInputs({ inputs: right })\r\n//   }\r\n// }\r\n\r\n// webflawless.data.url = {\r\n//   value: window.location.href,\r\n//   href: window.location.href,\r\n//   params: Object.fromEntries(new URLSearchParams(window.location.search).entries()),\r\n//   pathname: window.location.pathname,\r\n//   origin: window.location.origin,\r\n//   host: window.location.host,\r\n//   hash: window.location.hash\r\n// }\r\n\r\n// webflawless.data.context = {\r\n//   item: null,\r\n//   input: null\r\n// }\r\n\r\n// webflawless.data.saved = {\r\n//   local: window.localStorage.getItem('webflawless') || {},\r\n//   session: window.sessionStorage.getItem('webflawless') || {}\r\n// }\r\n\r\n// webflawless.data.getCookie = (name) => {\r\n//   return document.cookie.split(name + '=')[1]\r\n//     ? decodeURIComponent(document.cookie.split(name + '=')[1].split(';')[0])\r\n//     : null\r\n// }\r\n\r\n// webflawless.data.setCookie = ({ name, value }) => {\r\n//   document.cookie = name + '=' + encodeURIComponent(value)\r\n// }\r\n\r\n// webflawless.action = ({ type, selector, trigger, condition, params }) => {\r\n//   console.log({ type, selector, trigger, condition, params })\r\n\r\n//   const action = () => {\r\n//     if (typeof condition === 'undefined' || condition) {\r\n//       if (type === 'hide') {\r\n//         helpers.getNodesFromSelector({ selector }).map(el => {\r\n//           el.style.display = 'none'\r\n//           return null\r\n//         })\r\n//       } else if (type === 'request') {\r\n//         helpers.request({\r\n//           url: params.url,\r\n//           method: params.method,\r\n//           data: (params.inputs || params.data) && helpers.getInputs({ inputs: params.inputs || params.data, map: params.map }),\r\n//           headers: params.headers && helpers.getInputs({ inputs: params.headers }),\r\n//           urlParams: params.urlParams && helpers.getInputs({ inputs: params.urlParams }),\r\n//           saveAs: params.saveAs,\r\n//           actionOnLoad: params.actionOnLoad\r\n//         })\r\n//       } else if (type === 'replaceText') {\r\n//         helpers.getNodesFromSelector({ selector }).map(el => {\r\n//           el.innerText = helpers.getInputs({ inputs: params.value })\r\n//           return null\r\n//         })\r\n//       } else if (type === 'messageToIframeParent') {\r\n//         window.parent.postMessage(helpers.getInputs({ inputs: params.value }), '*')\r\n//       } else if (type === 'save') {\r\n//         const value = helpers.getInputs({ inputs: params.data, map: params.map })\r\n//         set(webflawless, params.as, value)\r\n//       } else if (type === 'setUrlParams') {\r\n//         if (selector) {\r\n//           helpers.getNodesFromSelector({ selector }).map(node => {\r\n//             if (node.href) {\r\n//               const url = new URL(node.href)\r\n//               const inputsData = helpers.getInputs({ inputs: params.inputs, map: params.map })\r\n\r\n//               for (const key in inputsData) {\r\n//                 url.searchParams.set(key, inputsData[key])\r\n//               }\r\n\r\n//               node.href = url.href\r\n//             }\r\n\r\n//             return null\r\n//           })\r\n//         } else {\r\n//           const url = new URL(window.location.href)\r\n//           const inputsData = helpers.getInputs({ inputs: params.inputs, map: params.map })\r\n\r\n//           for (const key in inputsData) {\r\n//             url.searchParams.set(key, inputsData[key])\r\n//           }\r\n\r\n//           window.history.replaceState(null, null, url)\r\n//         }\r\n//       } else if (type === 'iterate') {\r\n//         const contextNodes = helpers.getNodesFromSelector({ selector })\r\n//         const inputsData = helpers.getInputs({ inputs: params.inputs, map: params.map })\r\n\r\n//         contextNodes.map(contextNode => {\r\n//           if (contextNode.getAttribute('webflawless-clone')) {\r\n//             contextNode.remove()\r\n//           } else {\r\n//             inputsData.map((inputsItem, index) => {\r\n//               const newNode = contextNode.cloneNode(true)\r\n//               newNode.setAttribute('webflawless-index', index)\r\n//               newNode.setAttribute('webflawless-clone', true)\r\n//               newNode.setAttribute('webflawless-data', JSON.stringify(inputsItem))\r\n//               helpers.insertNodeAfter({ newNode, referenceNode: contextNode })\r\n\r\n//               const nodes = helpers.getNodesFromSelector({ selector: { type: 'tag' }, contextNode: newNode })\r\n\r\n//               nodes.map(node => helpers.replaceValueFromNode({\r\n//                 node,\r\n//                 inputs: inputsItem\r\n//               }))\r\n\r\n//               return null\r\n//             })\r\n\r\n//             contextNode.style.display = 'none'\r\n//           }\r\n\r\n//           return null\r\n//         })\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   const triggerAction = () => {\r\n//     if (trigger) {\r\n//       if (trigger.event === 'saved') {\r\n//         if (webflawless.data.saved[trigger.selector]) {\r\n//           action()\r\n//         }\r\n\r\n//         if (!listeners.saved[trigger.selector]) {\r\n//           listeners.saved[trigger.selector] = []\r\n//         }\r\n\r\n//         listeners.saved[trigger.selector].push({ type, selector, condition, params })\r\n//       } else {\r\n//         (helpers.getNodesFromSelector({ selector: trigger.selector }) || [window]).map(node => {\r\n//           node.addEventListener(trigger.event, () => {\r\n//             webflawless.data.context.input = node.value\r\n//             const iterateContainer = node.closest('[webflawless-data]')\r\n\r\n//             if (iterateContainer) {\r\n//               webflawless.data.context.item = JSON.parse(iterateContainer.getAttribute('webflawless-data'))\r\n//             }\r\n\r\n//             action()\r\n//           })\r\n\r\n//           return null\r\n//         })\r\n//       }\r\n//     } else {\r\n//       action()\r\n//     }\r\n//   }\r\n\r\n//   if (document.readyState === 'complete' || document.readyState === 'interactive') {\r\n//     triggerAction()\r\n//   } else {\r\n//     document.addEventListener('DOMContentLoaded', triggerAction)\r\n//   }\r\n// }\r\n\r\nwindow.webflawless = { caca: 'caca' }\r\n"],"names":["window","webflawless","caca"],"version":3,"file":"main.js.map"}